#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import gi
gi.require_version('Gimp', '3.0')
from gi.repository import Gimp
gi.require_version('GimpUi', '3.0')
from gi.repository import GimpUi
gi.require_version('Gegl', '0.4')
from gi.repository import Gegl
from gi.repository import GObject
from gi.repository import GLib
from gi.repository import Gio

import os
import sys



class scaleImage (Gimp.PlugIn):
    ## GimpPlugIn virtual methods ##
    def do_query_procedures(self):
        return [ "sk-plug-in-scale-image-python" ]

    def do_create_procedure(self, name):
        procedure = Gimp.ImageProcedure.new(self, name,
                                            Gimp.PDBProcType.PLUGIN,
                                            self.run, None)

        procedure.set_image_types("*")
        procedure.set_sensitivity_mask (Gimp.ProcedureSensitivityMask.DRAWABLE)

        procedure.set_menu_label("Scale image (px): 815x1063")
        procedure.set_icon_name(GimpUi.ICON_GEGL)
        procedure.add_menu_path('<Image>/Image/')

        procedure.set_documentation("My first Python Fu plugin in Gimp 3.0.4",
                                    "This will scale the image to width of 815 px and height of 1063 px",
                                    name)
        procedure.set_attribution("Sumod", "Sumod", "2025")

        return procedure

    def run(self, procedure, run_mode, image, drawables, config, run_data):
            
        counter = 1  # start counting from 1

        for img in Gimp.get_images():
            # Make sure the image is editable
            img.undo_group_start()

            # Set image resolution to 600 dpi by 600 dpi
            img.set_resolution(600, 600)

            # Scale the image to 815x1063
            width, height = 815, 1063
            img.scale(width, height)

            # Export the image
            output_folder = r"C:\Users\S10DIGITAL\Downloads\Pictures_out"
            os.makedirs(output_folder, exist_ok=True)
            output_path = os.path.join(output_folder, f"Pic{counter}.jpg")
            file = Gio.File.new_for_path(output_path)
            Gimp.file_save(Gimp.RunMode.NONINTERACTIVE, img, file, None)
            
            counter += 1  # increment for the next image

            # Update display and finish
            Gimp.displays_flush()
            img.undo_group_end()

        return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())    

Gimp.main(scaleImage.__gtype__, sys.argv)


***********************************************************************************************
				# Explanation:
***********************************************************************************************


# Above is the working version of Python Fu plugin for GIMP 3.0.4
# I need you to explain each and every line, syntax, function, relation, is it a python thing or a Gimp thing, in short please explain everything.

# Quick summary
# This script is a GIMP-3 Python plug-in that registers a procedure named sk-plug-in-scale-image-python. When run it iterates open images, groups undo operations, sets resolution, scales each image to 815×1063 px, and saves each as PicN.jpg to a Windows folder. The plugin is registered via Gimp.main(...) at the end.

# Legend
# [Python] — standard Python language or stdlib
# [gi / GObject Introspection] — gi and from gi.repository import ... — these are bindings provided via PyGObject/GObject Introspection
# [GIMP API] — things from the Gimp / GimpUi / Gegl namespaces and high-level GIMP behaviour
# [GLib / Gio] — GLib / GIO types and helpers used by GI (e.g., GLib.Error, Gio.File)

Line-by-line / block explanations

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#!/usr/bin/env python3 — [Python / OS]: Shebang. On Unix-like systems it tells the shell to run this file with python3. On Windows it’s ignored.
# -*- coding: utf-8 -*- — [Python]: file encoding marker. In Python 3 the default encoding is UTF-8 so this is mostly cosmetic/for older tools; harmless to keep.

# import gi
# gi.require_version('Gimp', '3.0')
# from gi.repository import Gimp
# gi.require_version('GimpUi', '3.0')
# from gi.repository import GimpUi
# gi.require_version('Gegl', '0.4')
# from gi.repository import Gegl
# from gi.repository import GObject
# from gi.repository import GLib
# from gi.repository import Gio
# import gi — [gi / GObject Introspection]: imports PyGObject introspection support. This module loads metadata that allows you to import libraries like Gimp, Gio, etc.

# gi.require_version('Gimp', '3.0') — [gi]: tells GI to load the Gimp introspection typelib version 3.0. Must be called before from gi.repository import Gimp. If you omit it you might get a different version loaded or an error.
# from gi.repository import Gimp — [GIMP API via gi]: imports the Gimp namespace (the GIMP 3 API). This is not a normal pure-Python package — it’s a binding generated by the GObject Introspection system.
# gi.require_version('GimpUi', '3.0') / from gi.repository import GimpUi — [GIMP UI]: imports GIMP UI helper constants, icons, etc. GimpUi.ICON_GEGL is used later.
# gi.require_version('Gegl', '0.4') / from gi.repository import Gegl — [GEGL]: imports GEGL (Generic Graphics Library) types. GEGL is the engine behind image operations in GIMP 3. You import it here in case you need GEGL nodes/ops (in this script it’s imported but not used).
# from gi.repository import GObject — [GObject]: base object system used by GI/GIMP; classes derive from GObject.
# from gi.repository import GLib — [GLib]: utility types (main loop, GLib.Error, time, etc.).
# from gi.repository import Gio — [GIO]: filesystem and IO abstractions (Gio.File is used later to represent a path in a GIO-friendly way).
# Note: gi.require_version is not a Python language requirement — it’s specific to the GI system and must appear before importing that particular namespace.

# import os
# import sys
# [Python]: standard library imports.
# os — filesystem helpers (os.makedirs, os.path.join used later).
# sys — system-level objects like sys.argv used at the very end.

# class scaleImage (Gimp.PlugIn):
    ## GimpPlugIn virtual methods ##
# [Python + GIMP API]: defines a Python class named scaleImage that inherits from Gimp.PlugIn.
# Gimp.PlugIn is a GObject class provided by the GIMP introspection API — it defines the plug-in lifecycle and virtual methods (do_query_procedures, do_create_procedure, run) that GIMP calls.
# In Python you override those methods to implement a plugin.

#     def do_query_procedures(self):
#         return [ "sk-plug-in-scale-image-python" ]
# do_query_procedures — [GIMP API / GObject virtual method]:
# This is a callback GIMP calls to ask your plugin what procedure names it implements.
# The method returns a list of procedure names (strings). These names are the identifiers that go into GIMP's Procedure Database (PDB).
# Here you return a single name: "sk-plug-in-scale-image-python". That’s the internal identifier you’ll see in GIMP’s procedural browser (or when calling from scripts).

#     def do_create_procedure(self, name):
#        procedure = Gimp.ImageProcedure.new(self, name,
#                                             Gimp.PDBProcType.PLUGIN,
#                                             self.run, None)
# do_create_procedure — [GIMP API]:
# GIMP asks your plugin to create a Gimp.Procedure object for each procedure name you announced above.
# Gimp.ImageProcedure.new(...) constructs an image procedure (a procedure that operates on an image).
# Parameters:
# self — the plugin instance (owner).
# name — the procedure name string (the same string you returned earlier).
# Gimp.PDBProcType.PLUGIN — an enum saying this is a plugin procedure.
# self.run — a Python callable that GIMP will call when the procedure is executed.
# None — user data (not used here).
# The returned procedure object is then configured with metadata below.
# Note: Gimp.ImageProcedure is a GIMP object; its constructor and methods are provided by the GIMP GI bindings.

#         procedure.set_image_types("*")
# [GIMP API]: set_image_types defines what image types this procedure accepts.
# "*" means accept any type (RGB, RGBA, grayscale, indexed) — wildcard.
# You could be more restrictive (e.g., "RGB*").

#         procedure.set_sensitivity_mask (Gimp.ProcedureSensitivityMask.DRAWABLE)
# [GIMP API]: set_sensitivity_mask controls when the menu item is enabled (sensitive).

# Gimp.ProcedureSensitivityMask.DRAWABLE means the procedure requires an active drawable (layer) to be available and the menu will be insensitive if no drawable is present.
# Sensitivity masks come from GIMP constants — used for proper UX in menus.

#         procedure.set_menu_label("Scale image (px): 815x1063")
# [GIMP API]: label shown in the menu. This is the human-readable text the user sees.

#         procedure.set_icon_name(GimpUi.ICON_GEGL)
# [GIMP UI]: sets an icon for the procedure/menu entry. GimpUi.ICON_GEGL is a predefined icon name from GimpUi. This is optional cosmetic metadata.

#         procedure.add_menu_path('<Image>/Image/')
# [GIMP API]: tells GIMP where to insert the menu entry.
# '<Image>/Image/' means put the procedure in the Image → Image menu path. The final menu label will be appended there.
# Format follows GIMP’s menu path convention (see GIMP docs / PDB helpers).

#         procedure.set_documentation("My first Python Fu plugin in Gimp 3.0.4",
#                                     "This will scale the image to width of 815 px and height of 1063 px",
#                                     name)
# [GIMP API]: set_documentation(short_help, long_help, proc_name) (roughly).
# First string is a short blurb.
# Second is longer documentation/help text.
# Third is a reference name or more detailed identifier (here they pass name).
# This text shows in GIMP’s procedure browser and helps users and scripts.

#         procedure.set_attribution("Sumod", "Sumod", "2025")
# [GIMP API]: attribution metadata: typically author, copyright, date or similar.
# Useful / recommended so users can see who wrote the plugin.

#         return procedure
# [GIMP API]: return the fully configured procedure object to GIMP. GIMP will register it in the PDB under the name you provided earlier.

#     def run(self, procedure, run_mode, image, drawables, config, run_data):
# [GIMP API]: run is the function that gets executed when the user runs the procedure (or a script calls it).
# Parameters:
# procedure — the Gimp.Procedure object that is running.
# run_mode — whether it’s Gimp.RunMode.INTERACTIVE or .NONINTERACTIVE — used if you want to pop GUI or run headless.
# image — the image object the procedure was invoked with (often the active image).
# drawables — the drawable(s) passed (selected layer(s)).
# config, run_data — additional data that GIMP/PDB may pass (often unused).
# Important: in this script the author doesn’t use the image parameter — instead they call Gimp.get_images() and operate on all open images. That’s a deliberate choice but is different from the usual pattern of operating only on the passed image.

# Inside run:
#         counter = 1  # start counting from 1
# [Python]: simple integer initialization to number output files (Pic1.jpg, Pic2.jpg, ...).

#         for img in Gimp.get_images():
# [GIMP API]: Gimp.get_images() returns a list (or iterable) of all open Gimp.Image objects in GIMP.
# The loop iterates every open image. As noted, this ignores the image argument — so the plugin acts on all open images rather than just the one the user had active.

#             # Make sure the image is editable
#             img.undo_group_start()
# [GIMP API]: img.undo_group_start() — starts an undo group in GIMP.
# All operations between undo_group_start() and undo_group_end() become a single undo step in the UI. That keeps a single "Undo" entry for the whole sequence.
# This is the correct pattern when altering images programmatically.

#             # Set image resolution to 600 dpi by 600 dpi
#             img.set_resolution(600, 600)
# [GIMP API]: sets the resolution / DPI metadata of the image (horizontal and vertical DPI). This affects print size metadata and some export behaviors, but it does not directly change pixel dimensions.

#             # Scale the image to 815x1063
#             width, height = 815, 1063
#             img.scale(width, height)
# width, height = 815, 1063 — [Python]: tuple unpacking, a compact way to assign two variables.
# img.scale(width, height) — [GIMP API]: resize the image to given pixel width and height. This is an in-place change to the pixel buffer.

#             # Export the image
#             output_folder = r"C:\Users\S10DIGITAL\Downloads\Pictures_out"
# r"..." — [Python]: raw string literal; backslashes are not treated as escape sequences. Useful for Windows paths.
# output_folder — the folder where JPGs will be written. Make sure the path is correct for the user running the plugin; on Linux the path would look different.

#             os.makedirs(output_folder, exist_ok=True)
# [Python stdlib]: os.makedirs creates directories recursively. exist_ok=True means "don’t raise an error if the directory already exists" (Python 3.2+ behavior).

#             output_path = os.path.join(output_folder, f"Pic{counter}.jpg")
# [Python]:
# os.path.join — builds a platform-correct file path by joining path components.

# f"Pic{counter}.jpg" — f-string (formatted string literal). On first iteration becomes "Pic1.jpg".

#             file = Gio.File.new_for_path(output_path)
# [GIO]: creates a Gio.File object representing output_path. GIMP/GIO APIs prefer Gio.File for file operations because they integrate with GLib/GIO virtual filesystems.

#             Gimp.file_save(Gimp.RunMode.NONINTERACTIVE, img, file, None)
# [GIMP API]: calls GIMP’s high-level file save helper.
# Gimp.RunMode.NONINTERACTIVE — run without showing dialogs (headless / scripted).

# img — the image to save.

# file — the Gio.File pointing to the target path.

# None — optional additional parameters (often used for format-specific parameters or exported drawable); passing None uses default behaviour.

# Important caveat: exact file_save signatures and expected parameters vary between GIMP 3.x versions and distributions. In many examples you may need to pass a drawable or additional params; this code works in your reported environment, but if you get errors on other systems check GIMP 3 API docs or introspect the method signature (e.g., via help(Gimp.file_save) inside GIMP’s python console).

#             counter += 1  # increment for the next image
# [Python]: increment the counter for the next filename.

#             # Update display and finish
#             Gimp.displays_flush()
#             img.undo_group_end()
# Gimp.displays_flush() — [GIMP API]: forces GIMP to redraw its image windows so the user sees the changes.

# img.undo_group_end() — [GIMP API]: end the undo group started earlier. All the operations between undo_group_start() and here are now a single undo step.

#         return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())
# [GIMP API / GLib]: plugins must return a value that says whether they succeeded.

# procedure.new_return_values() builds the return tuple expected by the PDB (Procedure Database).

# Gimp.PDBStatusType.SUCCESS — status code indicating success.

# GLib.Error() — an error object (if you have an error). Note: constructing GLib.Error() with no arguments is unusual; typically you either pass None (no error) or construct a GLib.Error(domain, code, message) if you want to return an actual error. Many example plugins simply return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, None). If your environment accepts the code as written, it’s fine; but if you see a complaint, change the second argument to None or a proper GLib.Error instance.

# Gimp.main(scaleImage.__gtype__, sys.argv)
# [GIMP API / gi / GObject]: this is the plugin entry point.

# Gimp.main(...) registers the plugin with GIMP and starts the plugin lifecycle.

# scaleImage.__gtype__ — __gtype__ is the GObject type identifier for the class; GIMP expects a GType to know what class to instantiate and register. This is idiomatic when writing GObject-based plugins in Python.

# sys.argv — optional command-line args forwarded to the plugin system; common boilerplate.

# Extra notes, gotchas, and suggestions (tell-it-like-it-is)
# You operate on all open images
# The run signature provides an image parameter (the image that invoked the plugin). You ignore it and loop for img in Gimp.get_images() instead. That’s fine if you intend to process every open image; if you intended to process only the active image, use the passed image parameter.
# Gimp.file_save signatures vary across versions
# If you get TypeError or similar about arguments, check the actual signature in your GIMP’s Python console (help(Gimp.file_save) or dir(Gimp)). Some builds require passing a drawable or filename string. This plugin works in your reported setup but may need tweaks on other machines.
# Returning error object
# Returning GLib.Error() with no args is odd. Prefer None as the second return value on success:
# return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, None)
# Or provide a real GLib.Error(domain, code, message) when failing.
# No exception handling
# Any exception will likely bubble up to GIMP and break plugin execution. If you want robustness, wrap the per-image code in try/except and generate a useful GLib.Error return or log with print().
# Image quality / interpolation
# If you care about the scaling algorithm, set interpolation before img.scale(...) (e.g., Gimp.context_set_interpolation(Gimp.InterpolationType.NOHALO) or whatever the API exposes) so resizing quality can be controlled. Right now the plugin uses whatever the default interpolation is.

# File format
# You force a .jpg extension. GIMP will choose the file saver based on the extension, but you might want to use GIMP export APIs or set format options (quality for JPEG, etc.).
# Raw path on non-Windows
# The path r"C:\Users\...\Pictures_out" will fail on Linux. Either detect platform or use a configurable directory.

# Imports you don’t use
# You import Gegl, GObject but don’t use them in this snippet. That’s fine — they’re often used in real plugins, but you can remove unused imports to keep things tidy.

# Minimal improvements example (quick, optional)
# If you want the plugin to process only the passed image and return cleanly, two small changes:
# Replace for img in Gimp.get_images(): with for img in (image,): or just use img = image.
# Return None for the error:

# ... inside run, operate on `image` instead of all images ...
# at the end:
# return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, None)


# 1. What is self? [Python OOP thing]
# In Python, self is not a keyword — it’s just a convention, but universally used.
# It refers to the instance of the class that the method is operating on.
# Example (plain Python):
# class Example:
#     def say_hello(self, name):
#         print(f"Hello {name}, I am {self}")
# obj = Example()
# obj.say_hello("Sumod")
# Here:
# obj.say_hello("Sumod") is syntactic sugar for Example.say_hello(obj, "Sumod").
# Python automatically passes the object instance (obj) as the first argument to the method → that’s what self is.
# So in your plugin class:
# class scaleImage(Gimp.PlugIn):
#     def do_query_procedures(self):
       ...
# self refers to the scaleImage object instance that GIMP created when it loaded your plugin.

# 2. Where do the run arguments come from?
# def run(self, procedure, run_mode, image, drawables, config, run_data):
# This is [GIMP API / GObject virtual method].
# You didn’t decide those arguments — GIMP did.
# When a user runs your plugin (via menu or PDB call), GIMP calls your run method and injects those arguments.
# Here’s what they mean:
# procedure — the Gimp.Procedure object that represents the procedure being run.
# (The same one you created in do_create_procedure.)
# run_mode — tells how the plugin was invoked. Possible values:
# 	Gimp.RunMode.INTERACTIVE (user ran it via the menu; you can show dialogs)
# 	Gimp.RunMode.NONINTERACTIVE (called by another script; no UI allowed)
# 	Gimp.RunMode.WITH_LAST_VALS (repeat with last-used settings)
# image — the image the procedure is being run on (the currently active image, if called from the UI).
# drawables — the layers/channels that were selected when the plugin was run.
# config — parameter values (if your procedure had configurable inputs defined, they’d come in here).
# run_data — extra data you can pass if needed (rarely used).
# So: These arguments don’t come from Python, they come from GIMP’s plugin host calling your method.

# 3. What about Gimp.ImageProcedure.new(self, name, Gimp.PDBProcType.PLUGIN, self.run, None)?
# This line is you constructing a procedure object and telling GIMP about it.
# Breakdown:
# procedure = Gimp.ImageProcedure.new(
#     self,                  # 1. The plugin instance (self)
#     name,                  # 2. The procedure name (string)
#     Gimp.PDBProcType.PLUGIN,  # 3. Procedure type (enum)
#     self.run,              # 4. The function that will execute it
#     None                   # 5. Optional user data
# )
# 1. self
# The owner of this procedure (your plugin object). GIMP tracks who created what.
# 2. name
# This is the unique string identifier for your procedure (same as in do_query_procedures). Example: "sk-plug-in-scale-image-python".
# 3. Gimp.PDBProcType.PLUGIN
# Enum constant telling GIMP this is a plugin-provided procedure, not a built-in.
# 4. self.run
# The callback function GIMP will call when someone executes this procedure.
# Here you pass a bound method (self.run), which is basically a reference to your instance’s run method.
# 5. None
# User data pointer — can be used to pass extra context, usually None in Python.
# So essentially, this line registers your procedure with GIMP, and ties the procedure’s execution to your run() method.

# 4. Relationship between the parts
# do_query_procedures → you tell GIMP “I provide this procedure name”.
# do_create_procedure → GIMP says “OK, give me the full definition of that procedure”, and you create it with Gimp.ImageProcedure.new(...).
# Inside that call, you point GIMP to your run() function → that’s where execution happens.
# Later, when a user runs your plugin (via the menu, command line, or another script), GIMP calls your run() method and injects the arguments it knows (procedure, run_mode, image, etc.).
# ✅ To sum it up:
# self = Python instance of your plugin (scaleImage). It’s passed automatically whenever you call an instance method. Pure Python OOP concept.
# run arguments = Provided by GIMP’s plugin system when your procedure is executed.
# Gimp.ImageProcedure.new(...) arguments = You are defining the procedure metadata:
# self → who owns it
# name → its identifier
# Gimp.PDBProcType.PLUGIN → procedure type
# self.run → callback when executed
# None → extra data (unused)


